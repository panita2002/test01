/**
 * DevExtreme (cjs/__internal/scheduler/options_validator/core/options_validator_error_handler.test.js)
 * Version: 24.2.3
 * Build date: Fri Dec 06 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
var _globals = require("@jest/globals");
var _options_validator_error_handler = require("../../../scheduler/options_validator/core/options_validator_error_handler");
class TestErrorHandler extends _options_validator_error_handler.OptionsValidatorErrorHandler {
    constructor(errorsMap, globalErrorHandler) {
        super(errorsMap, globalErrorHandler)
    }
}
const errorMap = {
    A: "E0",
    B: "E1",
    C: "E2",
    D: "E3"
};
const createGlobalErrorHandlerMock = () => ({
    logError: _globals.jest.fn(),
    throwError: _globals.jest.fn()
});
(0, _globals.describe)("OptionsValidatorErrorHandler", (() => {
    (0, _globals.it)('shouldn\'t call global error handler if options validator result is "true"', (() => {
        const globalErrorHandler = createGlobalErrorHandlerMock();
        const handler = new TestErrorHandler(errorMap, globalErrorHandler);
        handler.handleValidationResult(true);
        (0, _globals.expect)(globalErrorHandler.logError).not.toHaveBeenCalled();
        (0, _globals.expect)(globalErrorHandler.throwError).not.toHaveBeenCalled()
    }));
    (0, _globals.it)("shouldn't call global error handler if there is no error codes for validator's errors", (() => {
        const globalErrorHandler = createGlobalErrorHandlerMock();
        const handler = new TestErrorHandler({
            B: "E1"
        }, globalErrorHandler);
        handler.handleValidationResult({
            A: {
                fist: "error",
                second: "error"
            },
            C: {
                first: "error"
            },
            D: {
                some: "error"
            }
        });
        (0, _globals.expect)(globalErrorHandler.logError).not.toHaveBeenCalled();
        (0, _globals.expect)(globalErrorHandler.throwError).not.toHaveBeenCalled()
    }));
    (0, _globals.it)("should log validator's errors and throw the last one", (() => {
        const globalErrorHandler = createGlobalErrorHandlerMock();
        const handler = new TestErrorHandler(errorMap, globalErrorHandler);
        handler.handleValidationResult({
            A: {
                fist: "error",
                second: "error"
            },
            B: {
                some: "error"
            },
            C: {
                first: "error"
            },
            D: {
                error: "error"
            }
        });
        (0, _globals.expect)(globalErrorHandler.logError).toHaveBeenCalledWith("E0");
        (0, _globals.expect)(globalErrorHandler.logError).toHaveBeenCalledWith("E1");
        (0, _globals.expect)(globalErrorHandler.logError).toHaveBeenCalledWith("E2");
        (0, _globals.expect)(globalErrorHandler.throwError).toHaveBeenCalledWith("E3");
        (0, _globals.expect)(globalErrorHandler.logError).toHaveBeenCalledTimes(3);
        (0, _globals.expect)(globalErrorHandler.throwError).toHaveBeenCalledTimes(1)
    }));
    (0, _globals.it)("should log and throw only exising error codes", (() => {
        const globalErrorHandler = createGlobalErrorHandlerMock();
        const handler = new TestErrorHandler({
            A: "E0",
            C: "E2"
        }, globalErrorHandler);
        handler.handleValidationResult({
            A: {
                fist: "error",
                second: "error"
            },
            B: {
                some: "error"
            },
            C: {
                first: "error"
            },
            D: {
                error: "error"
            }
        });
        (0, _globals.expect)(globalErrorHandler.logError).toHaveBeenCalledWith("E0");
        (0, _globals.expect)(globalErrorHandler.throwError).toHaveBeenCalledWith("E2");
        (0, _globals.expect)(globalErrorHandler.logError).toHaveBeenCalledTimes(1);
        (0, _globals.expect)(globalErrorHandler.throwError).toHaveBeenCalledTimes(1)
    }));
    (0, _globals.it)("should throw single validator's error", (() => {
        const globalErrorHandler = createGlobalErrorHandlerMock();
        const handler = new TestErrorHandler(errorMap, globalErrorHandler);
        handler.handleValidationResult({
            B: {
                some: "error"
            }
        });
        (0, _globals.expect)(globalErrorHandler.logError).not.toHaveBeenCalled();
        (0, _globals.expect)(globalErrorHandler.throwError).toHaveBeenCalledWith("E1");
        (0, _globals.expect)(globalErrorHandler.throwError).toHaveBeenCalledTimes(1)
    }));
    (0, _globals.it)("should throw single validator's error if only one error code matches with it", (() => {
        const globalErrorHandler = createGlobalErrorHandlerMock();
        const handler = new TestErrorHandler({
            B: "E1"
        }, globalErrorHandler);
        handler.handleValidationResult({
            A: {
                fist: "error",
                second: "error"
            },
            B: {
                some: "error"
            },
            C: {
                first: "error"
            },
            D: {
                error: "error"
            }
        });
        (0, _globals.expect)(globalErrorHandler.logError).not.toHaveBeenCalled();
        (0, _globals.expect)(globalErrorHandler.throwError).toHaveBeenCalledWith("E1");
        (0, _globals.expect)(globalErrorHandler.throwError).toHaveBeenCalledTimes(1)
    }));
    (0, _globals.it)("shouldn't log the same error code more that one time", (() => {
        const globalErrorHandler = createGlobalErrorHandlerMock();
        const handler = new TestErrorHandler({
            A: "E0",
            B: "E0",
            C: "E1",
            D: "E1"
        }, globalErrorHandler);
        handler.handleValidationResult({
            A: {
                fist: "error",
                second: "error"
            },
            B: {
                some: "error"
            },
            C: {
                first: "error"
            },
            D: {
                error: "error"
            }
        });
        (0, _globals.expect)(globalErrorHandler.logError).toHaveBeenCalledWith("E0");
        (0, _globals.expect)(globalErrorHandler.throwError).toHaveBeenCalledWith("E1");
        (0, _globals.expect)(globalErrorHandler.logError).toHaveBeenCalledTimes(1);
        (0, _globals.expect)(globalErrorHandler.throwError).toHaveBeenCalledTimes(1)
    }))
}));
