/**
 * DevExtreme (cjs/__internal/events/core/m_emitter_registrator.js)
 * Version: 24.2.3
 * Build date: Fri Dec 06 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _event_registrator = _interopRequireDefault(require("../../../common/core/events/core/event_registrator"));
var _events_engine = _interopRequireDefault(require("../../../common/core/events/core/events_engine"));
var _wheel = require("../../../common/core/events/core/wheel");
var _pointer = _interopRequireDefault(require("../../../common/core/events/pointer"));
var _index = require("../../../common/core/events/utils/index");
var _class = _interopRequireDefault(require("../../../core/class"));
var _dom_adapter = _interopRequireDefault(require("../../../core/dom_adapter"));
var _element_data = require("../../../core/element_data");
var _renderer = _interopRequireDefault(require("../../../core/renderer"));
var _extend = require("../../../core/utils/extend");
var _iterator = require("../../../core/utils/iterator");
var _ready_callbacks = _interopRequireDefault(require("../../../core/utils/ready_callbacks"));

function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}
const MANAGER_EVENT = "dxEventManager";
const EMITTER_DATA = "dxEmitter";
const EventManager = _class.default.inherit({
    ctor() {
        this._attachHandlers();
        this.reset();
        this._proxiedCancelHandler = this._cancelHandler.bind(this);
        this._proxiedAcceptHandler = this._acceptHandler.bind(this)
    },
    _attachHandlers() {
        _ready_callbacks.default.add((() => {
            const document = _dom_adapter.default.getDocument();
            _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_pointer.default.down, MANAGER_EVENT), this._pointerDownHandler.bind(this));
            _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_pointer.default.move, MANAGER_EVENT), this._pointerMoveHandler.bind(this));
            _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)([_pointer.default.up, _pointer.default.cancel].join(" "), MANAGER_EVENT), this._pointerUpHandler.bind(this));
            _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_wheel.name, MANAGER_EVENT), this._mouseWheelHandler.bind(this))
        }))
    },
    _eachEmitter(callback) {
        const activeEmitters = this._activeEmitters || [];
        let i = 0;
        while (activeEmitters.length > i) {
            const emitter = activeEmitters[i];
            if (false === callback(emitter)) {
                break
            }
            if (activeEmitters[i] === emitter) {
                i++
            }
        }
    },
    _applyToEmitters(method, arg) {
        this._eachEmitter((emitter => {
            emitter[method].call(emitter, arg)
        }))
    },
    reset() {
        this._eachEmitter(this._proxiedCancelHandler);
        this._activeEmitters = []
    },
    resetEmitter(emitter) {
        this._proxiedCancelHandler(emitter)
    },
    _pointerDownHandler(e) {
        if ((0, _index.isMouseEvent)(e) && e.which > 1) {
            return
        }
        this._updateEmitters(e)
    },
    _updateEmitters(e) {
        if (!this._isSetChanged(e)) {
            return
        }
        this._cleanEmitters(e);
        this._fetchEmitters(e)
    },
    _isSetChanged(e) {
        const currentSet = this._closestEmitter(e);
        const previousSet = this._emittersSet || [];
        let setChanged = currentSet.length !== previousSet.length;
        (0, _iterator.each)(currentSet, ((index, emitter) => {
            setChanged = setChanged || previousSet[index] !== emitter;
            return !setChanged
        }));
        this._emittersSet = currentSet;
        return setChanged
    },
    _closestEmitter(e) {
        const that = this;
        const result = [];
        let $element = (0, _renderer.default)(e.target);

        function handleEmitter(_, emitter) {
            if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
                emitter.addCancelCallback(that._proxiedCancelHandler);
                emitter.addAcceptCallback(that._proxiedAcceptHandler);
                result.push(emitter)
            }
        }
        while ($element.length) {
            const emitters = (0, _element_data.data)($element.get(0), "dxEmitter") || [];
            (0, _iterator.each)(emitters, handleEmitter);
            $element = $element.parent()
        }
        return result
    },
    _acceptHandler(acceptedEmitter, e) {
        this._eachEmitter((emitter => {
            if (emitter !== acceptedEmitter) {
                this._cancelEmitter(emitter, e)
            }
        }))
    },
    _cancelHandler(canceledEmitter, e) {
        this._cancelEmitter(canceledEmitter, e)
    },
    _cancelEmitter(emitter, e) {
        const activeEmitters = this._activeEmitters;
        if (e) {
            emitter.cancel(e)
        } else {
            emitter.reset()
        }
        emitter.removeCancelCallback();
        emitter.removeAcceptCallback();
        const emitterIndex = activeEmitters.indexOf(emitter);
        if (emitterIndex > -1) {
            activeEmitters.splice(emitterIndex, 1)
        }
    },
    _cleanEmitters(e) {
        this._applyToEmitters("end", e);
        this.reset(e)
    },
    _fetchEmitters(e) {
        this._activeEmitters = this._emittersSet.slice();
        this._applyToEmitters("start", e)
    },
    _pointerMoveHandler(e) {
        this._applyToEmitters("move", e)
    },
    _pointerUpHandler(e) {
        this._updateEmitters(e)
    },
    _mouseWheelHandler(e) {
        if (!this._allowInterruptionByMouseWheel()) {
            return
        }
        e.pointers = [null];
        this._pointerDownHandler(e);
        this._adjustWheelEvent(e);
        this._pointerMoveHandler(e);
        e.pointers = [];
        this._pointerUpHandler(e)
    },
    _allowInterruptionByMouseWheel() {
        let allowInterruption = true;
        this._eachEmitter((emitter => {
            allowInterruption = emitter.allowInterruptionByMouseWheel() && allowInterruption;
            return allowInterruption
        }));
        return allowInterruption
    },
    _adjustWheelEvent(e) {
        let closestGestureEmitter = null;
        this._eachEmitter((emitter => {
            if (!emitter.gesture) {
                return
            }
            const direction = emitter.getDirection(e);
            if ("horizontal" !== direction && !e.shiftKey || "vertical" !== direction && e.shiftKey) {
                closestGestureEmitter = emitter;
                return false
            }
        }));
        if (!closestGestureEmitter) {
            return
        }
        const direction = closestGestureEmitter.getDirection(e);
        const verticalGestureDirection = "both" === direction && !e.shiftKey || "vertical" === direction;
        const prop = verticalGestureDirection ? "pageY" : "pageX";
        e[prop] += e.delta
    },
    isActive(element) {
        let result = false;
        this._eachEmitter((emitter => {
            result = result || emitter.getElement().is(element)
        }));
        return result
    }
});
const eventManager = new EventManager;
const EMITTER_SUBSCRIPTION_DATA = "dxEmitterSubscription";
const registerEmitter = function(emitterConfig) {
    const EmitterClass = emitterConfig.emitter;
    const emitterName = emitterConfig.events[0];
    const emitterEvents = emitterConfig.events;
    (0, _iterator.each)(emitterEvents, ((_, eventName) => {
        (0, _event_registrator.default)(eventName, {
            noBubble: !emitterConfig.bubble,
            setup(element) {
                const subscriptions = (0, _element_data.data)(element, "dxEmitterSubscription") || {};
                const emitters = (0, _element_data.data)(element, "dxEmitter") || {};
                const emitter = emitters[emitterName] || new EmitterClass(element);
                subscriptions[eventName] = true;
                emitters[emitterName] = emitter;
                (0, _element_data.data)(element, "dxEmitter", emitters);
                (0, _element_data.data)(element, "dxEmitterSubscription", subscriptions)
            },
            add(element, handleObj) {
                const emitters = (0, _element_data.data)(element, "dxEmitter");
                const emitter = emitters[emitterName];
                emitter.configure((0, _extend.extend)({
                    delegateSelector: handleObj.selector
                }, handleObj.data), handleObj.type)
            },
            teardown(element) {
                const subscriptions = (0, _element_data.data)(element, "dxEmitterSubscription");
                const emitters = (0, _element_data.data)(element, "dxEmitter");
                const emitter = emitters[emitterName];
                delete subscriptions[eventName];
                let disposeEmitter = true;
                (0, _iterator.each)(emitterEvents, ((_, eventName) => {
                    disposeEmitter = disposeEmitter && !subscriptions[eventName];
                    return disposeEmitter
                }));
                if (disposeEmitter) {
                    if (eventManager.isActive(element)) {
                        eventManager.resetEmitter(emitter)
                    }
                    emitter && emitter.dispose();
                    delete emitters[emitterName]
                }
            }
        })
    }))
};
var _default = exports.default = registerEmitter;
