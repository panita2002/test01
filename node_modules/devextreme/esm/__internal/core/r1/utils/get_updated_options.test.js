/**
 * DevExtreme (esm/__internal/core/r1/utils/get_updated_options.test.js)
 * Version: 24.2.3
 * Build date: Fri Dec 06 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import {
    describe,
    expect,
    it
} from "@jest/globals";
import {
    getUpdatedOptions
} from "./get_updated_options";
describe("get_updated_options", (() => {
    class DummyDataSource {
        constructor() {
            this.dummy = true
        }
    }
    it("simple props changed", (() => {
        expect(getUpdatedOptions({
            visible: true
        }, {
            visible: false
        })).toEqual([{
            path: "visible",
            value: false,
            previousValue: true
        }])
    }));
    it("no props changed", (() => {
        expect(getUpdatedOptions({
            visible: true
        }, {
            visible: true
        })).toEqual([])
    }));
    it("new props", (() => {
        expect(getUpdatedOptions({
            visible: true
        }, {
            visible: true,
            enabled: false
        })).toEqual([{
            path: "enabled",
            value: false,
            previousValue: void 0
        }])
    }));
    it("old and new is undefined", (() => {
        expect(getUpdatedOptions({
            columns: void 0
        }, {
            columns: void 0
        })).toEqual([])
    }));
    it("eventcallback props changed", (() => {
        const callback1 = () => {};
        const callback2 = () => {};
        expect(getUpdatedOptions({
            visible: true,
            onCellClick: callback1
        }, {
            visible: true,
            onCellClick: callback2
        })).toEqual([{
            path: "onCellClick",
            value: callback2,
            previousValue: callback1
        }])
    }));
    it("nested props changed", (() => {
        expect(getUpdatedOptions({
            editing: {
                allowAdding: true
            }
        }, {
            editing: {
                allowAdding: false
            }
        })).toEqual([{
            path: "editing.allowAdding",
            value: false,
            previousValue: true
        }])
    }));
    it("nested props changed to empty", (() => {
        expect(getUpdatedOptions({
            visible: true,
            editing: {
                allowAdding: true
            }
        }, {
            visible: true
        })).toEqual([{
            path: "editing",
            value: void 0,
            previousValue: {
                allowAdding: true
            }
        }])
    }));
    it("type of value in props changed", (() => {
        expect(getUpdatedOptions({
            visible: true,
            filterValue: []
        }, {
            visible: true,
            filterValue: "1"
        })).toEqual([{
            path: "filterValue",
            value: "1",
            previousValue: []
        }])
    }));
    it("array item props changed", (() => {
        const oldColumns = [{
            id: "field1",
            visible: true
        }, {
            id: "field2",
            visible: true
        }];
        const columns = [oldColumns[0], _extends({}, oldColumns[1], {
            visible: false
        })];
        expect(getUpdatedOptions({
            columns: oldColumns
        }, {
            columns: columns
        })).toEqual([{
            path: "columns[1].visible",
            value: false,
            previousValue: true
        }])
    }));
    it("array items count changed", (() => {
        const oldColumns = [{
            id: "field1",
            visible: true
        }, {
            id: "field2",
            visible: true
        }];
        const columns = [...oldColumns, {
            id: "field3",
            visible: true
        }];
        expect(getUpdatedOptions({
            columns: oldColumns
        }, {
            columns: columns
        })).toEqual([{
            path: "columns",
            value: columns,
            previousValue: oldColumns
        }])
    }));
    it("ignore react props", (() => {
        expect(getUpdatedOptions({
            key: "grid1",
            ref: {},
            children: []
        }, {
            key: "grid2",
            ref: {},
            children: []
        })).toEqual([])
    }));
    it("not to deep equal for equal object", (() => {
        const obj = {
            ref: null
        };
        const refObj = {
            ref: obj
        };
        obj.ref = refObj;
        const dataSource = [obj];
        expect(getUpdatedOptions({
            dataSource: dataSource
        }, {
            dataSource: dataSource
        })).toEqual([])
    }));
    it('use equal for compare array "dataSource"', (() => {
        expect(getUpdatedOptions({
            dataSource: []
        }, {
            dataSource: []
        })).toEqual([{
            path: "dataSource",
            value: [],
            previousValue: []
        }])
    }));
    it("prevProps is undefined", (() => {
        expect(getUpdatedOptions({
            focusedRowKey: null
        }, {
            focusedRowKey: 0
        })).toEqual([{
            path: "focusedRowKey",
            value: 0,
            previousValue: null
        }])
    }));
    it("deep diff if plain object", (() => {
        const diff = getUpdatedOptions({
            items: [{
                location: "before"
            }]
        }, {
            items: [{
                location: "after"
            }]
        });
        expect(diff).toEqual([{
            path: "items[0].location",
            value: "after",
            previousValue: "before"
        }])
    }));
    it("deep diff only for plain object", (() => {
        const oldObj = {
            dataSource: new DummyDataSource
        };
        const obj = {
            dataSource: new DummyDataSource
        };
        expect(getUpdatedOptions(oldObj, obj)).toEqual([{
            path: "dataSource",
            value: obj.dataSource,
            previousValue: oldObj.dataSource
        }])
    }));
    it("using notDeepDiffArrays param", (() => {
        expect(getUpdatedOptions({
            toolbar: {
                items: [{
                    value: 1
                }]
            }
        }, {
            toolbar: {
                items: [{
                    value: 2
                }]
            }
        }, ["toolbar.items"])).toEqual([{
            path: "toolbar.items",
            value: [{
                value: 2
            }],
            previousValue: [{
                value: 1
            }]
        }])
    }));
    it("using defaultNotDeepDiffArrays", (() => {
        expect(getUpdatedOptions({
            toolbar: {
                dataSource: [{
                    value: 1
                }]
            }
        }, {
            toolbar: {
                dataSource: [{
                    value: 2
                }]
            }
        })).toEqual([{
            path: "toolbar.dataSource",
            value: [{
                value: 2
            }],
            previousValue: [{
                value: 1
            }]
        }])
    }));
    it("integration options are ignored", (() => {
        expect(getUpdatedOptions({
            visible: true,
            integrationOptions: true
        }, {
            visible: false,
            integrationOptions: void 0
        })).toEqual([{
            path: "visible",
            value: false,
            previousValue: true
        }])
    }));
    it("integration options in child props are ignored", (() => {
        expect(getUpdatedOptions({
            visible: true,
            items: {
                integrationOptions: true,
                disabled: true
            }
        }, {
            visible: false,
            items: {
                integrationOptions: void 0,
                disabled: false
            }
        })).toEqual([{
            path: "visible",
            value: false,
            previousValue: true
        }, {
            path: "items.disabled",
            value: false,
            previousValue: true
        }])
    }))
}));
