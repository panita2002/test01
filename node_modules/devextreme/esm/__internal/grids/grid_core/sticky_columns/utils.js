/**
 * DevExtreme (esm/__internal/grids/grid_core/sticky_columns/utils.js)
 * Version: 24.2.3
 * Build date: Fri Dec 06 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import {
    isDefined
} from "../../../../core/utils/type";
import gridCoreUtils from "../../../grids/grid_core/m_utils";
import {
    HIDDEN_COLUMNS_WIDTH
} from "../adaptivity/const";
import {
    STICKY_BORDER_WIDTH,
    StickyPosition
} from "./const";
export const getColumnFixedPosition = (that, column) => {
    const {
        fixedPosition: fixedPosition
    } = column;
    const rtlEnabled = that.option("rtlEnabled");
    const isExceptionCommandColumn = column.command && "expand" === column.command;
    const isDefaultCommandColumn = column.command && !gridCoreUtils.isCustomCommandColumn(that._columns, column);
    if (isDefaultCommandColumn && rtlEnabled && !isExceptionCommandColumn) {
        return fixedPosition === StickyPosition.Right ? StickyPosition.Left : StickyPosition.Right
    }
    return fixedPosition ?? StickyPosition.Left
};
export const needToDisableStickyColumn = function(that, column) {
    return that.isVirtualMode() && !!column.fixed && column.fixedPosition === StickyPosition.Sticky
};
export const processFixedColumns = function(that, columns) {
    return columns.map((column => {
        if (needToDisableStickyColumn(that, column)) {
            return _extends({}, column, {
                fixed: false,
                fixedPosition: ""
            })
        }
        return column
    }))
};
const isVisibleColumn = function(that, column) {
    return column.visibleWidth !== HIDDEN_COLUMNS_WIDTH && (!column.isBand || !!that.getVisibleDataColumnsByBandColumn(column.index).length)
};
const areNextOnlyFixedOrHiddenColumns = function(that, columns) {
    return !columns.some((column => !column.fixed && isVisibleColumn(that, column)))
};
const getStickyOffsetCore = function(that, columns, widths, columnIndex, fixedPosition, offsets) {
    const column = columns[columnIndex];
    const isChildColumn = isDefined(column.ownerBand);
    const targetColumnIsRight = fixedPosition === StickyPosition.Right;
    const targetColumnIsSticky = column.fixedPosition === StickyPosition.Sticky;
    const nextOrPrevColumns = targetColumnIsRight ? columns.slice(columnIndex + 1) : columns.slice(0, columnIndex).reverse();
    const nextOrPrevColumnWidths = targetColumnIsRight ? widths.slice(columnIndex + 1) : widths.slice(0, columnIndex).reverse();
    let offset = 0;
    let adjacentStickyColumnIndex = 0;
    let nonSiblingStickyColumnCount = !areNextOnlyFixedOrHiddenColumns(that, nextOrPrevColumns) && targetColumnIsSticky && nextOrPrevColumns.length ? 1 : 0;
    nextOrPrevColumns.forEach(((col, colIndex) => {
        if (col.fixed && (!isDefined(offsets) || column.ownerBand === col.ownerBand)) {
            const columnIsSticky = col.fixedPosition === StickyPosition.Sticky;
            offset += nextOrPrevColumnWidths[colIndex];
            if (targetColumnIsSticky && columnIsSticky && !areNextOnlyFixedOrHiddenColumns(that, nextOrPrevColumns.slice(colIndex + 1))) {
                if (colIndex !== adjacentStickyColumnIndex) {
                    nonSiblingStickyColumnCount += 1;
                    adjacentStickyColumnIndex = colIndex + 1
                } else {
                    adjacentStickyColumnIndex += 1
                }
            }
        } else if (!isVisibleColumn(that, col)) {
            adjacentStickyColumnIndex += 1
        }
    }));
    if (isChildColumn && isDefined(offsets)) {
        var _offsets$column$owner;
        offset += (null === offsets || void 0 === offsets || null === (_offsets$column$owner = offsets[column.ownerBand]) || void 0 === _offsets$column$owner ? void 0 : _offsets$column$owner[fixedPosition]) ?? 0;
        return offset
    }
    return offset - nonSiblingStickyColumnCount * STICKY_BORDER_WIDTH
};
const isFirstOrLastColumn = function(that, column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
    let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;
    const rtlEnabled = that.option("rtlEnabled");
    const methodName = rtlEnabled !== isLast ? "isLastColumn" : "isFirstColumn";
    if (column.fixedPosition === StickyPosition.Sticky) {
        const parentColumn = that.getParentColumn(column) ?? column;
        if (that[methodName](parentColumn, 0)) {
            return false
        }
    }
    return that[methodName](column, rowIndex, onlyWithinBandColumn, fixedPosition)
};
const getPrevColumn = function(that, column, visibleColumns, rowIndex) {
    const visibleColumnIndex = that.getVisibleIndex(column.index, rowIndex);
    return null === visibleColumns || void 0 === visibleColumns ? void 0 : visibleColumns.slice(0, visibleColumnIndex).reverse().find((col => isVisibleColumn(that, col)))
};
export const getStickyOffset = function(that, columns, widths, columnIndex, offsets) {
    const result = {};
    const column = columns[columnIndex];
    if (column) {
        const fixedPosition = getColumnFixedPosition(that, column);
        switch (fixedPosition) {
            case StickyPosition.Sticky: {
                const offsetLeft = getStickyOffsetCore(that, columns, widths, columnIndex, StickyPosition.Left, offsets);
                const offsetRight = getStickyOffsetCore(that, columns, widths, columnIndex, StickyPosition.Right, offsets);
                result.left = offsetLeft;
                result.right = offsetRight;
                break
            }
            case StickyPosition.Right: {
                const offsetRight = getStickyOffsetCore(that, columns, widths, columnIndex, StickyPosition.Right, offsets);
                result.right = offsetRight;
                break
            }
            default: {
                const offsetLeft = getStickyOffsetCore(that, columns, widths, columnIndex, StickyPosition.Left, offsets);
                result.left = offsetLeft
            }
        }
    }
    return result
};
const needToRemoveColumnBorderCore = function(that, column, visibleColumns, rowIndex) {
    const prevColumn = getPrevColumn(that, column, visibleColumns, rowIndex);
    const columnFixedPosition = getColumnFixedPosition(that, column);
    const prevColumnFixedPosition = prevColumn && getColumnFixedPosition(that, prevColumn);
    return !!(null !== prevColumn && void 0 !== prevColumn && prevColumn.fixed) && !needToDisableStickyColumn(that, prevColumn) && (!column.fixed || columnFixedPosition === StickyPosition.Sticky || prevColumnFixedPosition === StickyPosition.Sticky)
};
export const needToRemoveColumnBorder = function(that, column, rowIndex) {
    let isDataColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
    const visibleColumns = that.getVisibleColumns(isDataColumn ? null : rowIndex);
    const parentColumn = that.getParentColumn(column);
    if (parentColumn) {
        const isFirstColumn = that.isFirstColumn(column, rowIndex, true);
        return isFirstColumn && needToRemoveColumnBorderCore(that, parentColumn, that.getVisibleColumns(0), 0)
    }
    return needToRemoveColumnBorderCore(that, column, visibleColumns, rowIndex)
};
export const normalizeOffset = function(offset) {
    const styleProps = {};
    if (isDefined(offset.left)) {
        styleProps.left = `${offset.left}px`
    }
    if (isDefined(offset.right)) {
        styleProps.right = `${offset.right}px`
    }
    return styleProps
};
export const isFirstFixedColumn = function(that, column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
    let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
    return isFirstOrLastColumn(that, column, rowIndex, onlyWithinBandColumn, false, fixedPosition)
};
export const isLastFixedColumn = function(that, column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
    let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
    return isFirstOrLastColumn(that, column, rowIndex, onlyWithinBandColumn, true, fixedPosition)
};
export const isFixedEdge = function(point, column, nextColumn) {
    const isSplitPoint = isDefined(point.isLeftBoundary) || isDefined(point.isRightBoundary);
    return !isSplitPoint && !!column && !!nextColumn && column.fixed !== nextColumn.fixed
};
