/**
 * DevExtreme (esm/__internal/grids/grid_core/sticky_columns/m_sticky_columns.js)
 * Version: 24.2.3
 * Build date: Fri Dec 06 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import $ from "../../../../core/renderer";
import {
    getBoundingRect
} from "../../../../core/utils/position";
import {
    setWidth
} from "../../../../core/utils/size";
import {
    getElementLocationInternal
} from "../../../ui/scroll_view/utils/get_element_location_internal";
import {
    HIDDEN_COLUMNS_WIDTH
} from "../adaptivity/const";
import {
    isAdaptiveItem,
    isGroupFooterRow,
    isGroupRow as isGroupRowElement
} from "../keyboard_navigation/m_keyboard_navigation_utils";
import gridCoreUtils from "../m_utils";
import {
    CLASSES as MASTER_DETAIL_CLASSES
} from "../master_detail/const";
import {
    isGroupRow
} from "../views/m_rows_view";
import {
    CLASSES,
    StickyPosition
} from "./const";
import {
    GridCoreStickyColumnsDom
} from "./dom";
import {
    getColumnFixedPosition,
    getStickyOffset,
    isFirstFixedColumn,
    isFixedEdge,
    isLastFixedColumn,
    needToDisableStickyColumn,
    needToRemoveColumnBorder,
    normalizeOffset,
    processFixedColumns
} from "./utils";
const baseStickyColumns = Base => class extends Base {
    _addStickyColumnBorderLeftClass($cell, column, rowIndex) {
        let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
        let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
        const isFirstFixedCell = isFirstFixedColumn(this._columnsController, column, rowIndex, onlyWithinBandColumn, fixedPosition);
        if (isFirstFixedCell) {
            GridCoreStickyColumnsDom.addStickyColumnBorderLeftClass($cell, this.addWidgetPrefix.bind(this))
        }
    }
    _addStickyColumnBorderRightClass($cell, column, rowIndex) {
        let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
        let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
        const isLastFixedCell = isLastFixedColumn(this._columnsController, column, rowIndex, onlyWithinBandColumn, fixedPosition);
        if (isLastFixedCell) {
            GridCoreStickyColumnsDom.addStickyColumnBorderRightClass($cell, this.addWidgetPrefix.bind(this))
        }
    }
    updateBorderCellClasses($cell, column, rowIndex) {
        const columnsController = this._columnsController;
        const isRowsView = "rowsView" === this.name;
        const needToRemoveBorder = needToRemoveColumnBorder(columnsController, column, rowIndex, isRowsView);
        const isFirstColumn = null === columnsController || void 0 === columnsController ? void 0 : columnsController.isFirstColumn(column, rowIndex);
        GridCoreStickyColumnsDom.toggleColumnNoBorderClass($cell, needToRemoveBorder, this.addWidgetPrefix.bind(this));
        GridCoreStickyColumnsDom.toggleFirstHeaderClass($cell, isFirstColumn, this.addWidgetPrefix.bind(this))
    }
    _updateBorderClasses() {
        const isColumnHeadersView = "columnHeadersView" === this.name;
        const $rows = this._getRowElementsCore().not(`.${MASTER_DETAIL_CLASSES.detailRow}`).toArray();
        $rows.forEach(((row, index) => {
            const rowIndex = isColumnHeadersView ? index : null;
            const $cells = $(row).children("td").toArray();
            let columns = this.getColumns(rowIndex);
            columns = processFixedColumns(this._columnsController, columns);
            $cells.forEach(((cell, cellIndex) => {
                const $cell = $(cell);
                const column = columns[cellIndex];
                if (column.visibleWidth !== HIDDEN_COLUMNS_WIDTH) {
                    this.updateBorderCellClasses($cell, column, rowIndex)
                }
            }))
        }))
    }
    _renderCore(options) {
        super._renderCore(options);
        const $element = this.element();
        const hasStickyColumns = this.hasStickyColumns();
        GridCoreStickyColumnsDom.toggleStickyColumnsClass($element, hasStickyColumns, this.addWidgetPrefix.bind(this))
    }
    _createCell(options) {
        const {
            column: column
        } = options;
        const {
            rowType: rowType
        } = options;
        const $cell = super._createCell(options);
        const hasStickyColumns = this.hasStickyColumns();
        const rowIndex = "header" === rowType ? options.rowIndex : null;
        const isSummary = "groupFooter" === rowType || "totalFooter" === rowType || "group" === rowType;
        const isExpandColumn = column.command && "expand" === column.command;
        if (hasStickyColumns && !needToDisableStickyColumn(this._columnsController, column)) {
            this.updateBorderCellClasses($cell, column, rowIndex);
            if (column.fixed) {
                const fixedPosition = getColumnFixedPosition(this._columnsController, column);
                GridCoreStickyColumnsDom.addStickyColumnClass($cell, fixedPosition, this.addWidgetPrefix.bind(this));
                if (!isSummary && !isExpandColumn) {
                    switch (fixedPosition) {
                        case StickyPosition.Right:
                            this._addStickyColumnBorderLeftClass($cell, column, rowIndex, false, StickyPosition.Right);
                            break;
                        case StickyPosition.Sticky:
                            this._addStickyColumnBorderLeftClass($cell, column, rowIndex, true);
                            this._addStickyColumnBorderRightClass($cell, column, rowIndex, true);
                            break;
                        default:
                            this._addStickyColumnBorderRightClass($cell, column, rowIndex, false, StickyPosition.Left)
                    }
                }
            }
        }
        return $cell
    }
    setStickyOffsets(rowIndex, offsets) {
        const columnsController = this._columnsController;
        const rtlEnabled = this.option("rtlEnabled");
        const showColumnHeaders = this.option("showColumnHeaders");
        let widths = this.getColumnWidths(void 0, rowIndex);
        let columns = this.getColumns(showColumnHeaders ? rowIndex : void 0);
        columns = processFixedColumns(this._columnsController, columns);
        if (rtlEnabled) {
            columns = rtlEnabled ? [...columns].reverse() : columns;
            widths = rtlEnabled ? [...widths].reverse() : widths
        }
        columns.forEach(((column, columnIndex) => {
            if (column.fixed) {
                const visibleColumnIndex = rtlEnabled ? columns.length - columnIndex - 1 : columnIndex;
                const offset = getStickyOffset(columnsController, columns, widths, columnIndex, offsets);
                if (offsets) {
                    offsets[column.index] = offset
                }
                const styleProps = normalizeOffset(offset);
                this.setCellProperties(styleProps, visibleColumnIndex, rowIndex)
            }
        }))
    }
    setColumnWidths(options) {
        const hasStickyColumns = this.hasStickyColumns();
        const columnsResizerController = this.getController("columnsResizer");
        const isColumnResizing = null === columnsResizerController || void 0 === columnsResizerController ? void 0 : columnsResizerController.isResizing();
        super.setColumnWidths(options);
        if (hasStickyColumns && isColumnResizing) {
            this.setStickyOffsets()
        }
    }
    _resizeCore() {
        const hasStickyColumns = this.hasStickyColumns();
        const adaptiveColumns = this.getController("adaptiveColumns");
        const hidingColumnsQueue = null === adaptiveColumns || void 0 === adaptiveColumns ? void 0 : adaptiveColumns.getHidingColumnsQueue();
        super._resizeCore.apply(this, arguments);
        if (hasStickyColumns) {
            this.setStickyOffsets();
            if (null !== hidingColumnsQueue && void 0 !== hidingColumnsQueue && hidingColumnsQueue.length) {
                this._updateBorderClasses()
            }
        }
    }
    hasStickyColumns() {
        var _this$_columnsControl;
        const stickyColumns = null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.getStickyColumns();
        return true !== this.option("columnFixing.legacyMode") && !!stickyColumns.length
    }
};
const columnHeadersView = Base => class extends(baseStickyColumns(Base)) {
    setStickyOffsets() {
        const offsets = {};
        const rows = this._getRows();
        for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            var _rows$rowIndex;
            const isFilterRow = "filter" === (null === rows || void 0 === rows || null === (_rows$rowIndex = rows[rowIndex]) || void 0 === _rows$rowIndex ? void 0 : _rows$rowIndex.rowType);
            super.setStickyOffsets(rowIndex, isFilterRow ? void 0 : offsets)
        }
    }
    getContextMenuItems(options) {
        const {
            column: column
        } = options;
        const columnsController = this._columnsController;
        const columnFixingOptions = this.option("columnFixing");
        let items = super.getContextMenuItems(options);
        if (options.row && "header" === options.row.rowType) {
            if (true === columnFixingOptions.enabled && column && column.allowFixing) {
                const onItemClick = params => {
                    switch (params.itemData.value) {
                        case "none":
                            this._columnsController.columnOption(column.index, "fixed", false);
                            break;
                        case "left":
                            this._columnsController.columnOption(column.index, {
                                fixed: true,
                                fixedPosition: "left"
                            });
                            break;
                        case "right":
                            this._columnsController.columnOption(column.index, {
                                fixed: true,
                                fixedPosition: "right"
                            });
                            break;
                        case "sticky":
                            this._columnsController.columnOption(column.index, {
                                fixed: true,
                                fixedPosition: "sticky"
                            })
                    }
                };
                const fixedPositionItems = [{
                    text: columnFixingOptions.texts.leftPosition,
                    icon: columnFixingOptions.icons.leftPosition,
                    value: "left",
                    disabled: column.fixed && (!column.fixedPosition || "left" === column.fixedPosition),
                    onItemClick: onItemClick
                }, {
                    text: columnFixingOptions.texts.rightPosition,
                    icon: columnFixingOptions.icons.rightPosition,
                    value: "right",
                    disabled: column.fixed && "right" === column.fixedPosition,
                    onItemClick: onItemClick
                }];
                if (true !== this.option("columnFixing.legacyMode") && !columnsController.isVirtualMode()) {
                    fixedPositionItems.push({
                        text: columnFixingOptions.texts.stickyPosition,
                        icon: columnFixingOptions.icons.stickyPosition,
                        value: "sticky",
                        disabled: column.fixed && column.fixedPosition === StickyPosition.Sticky,
                        onItemClick: onItemClick
                    })
                }
                items = items || [];
                items.push({
                    text: columnFixingOptions.texts.fix,
                    icon: columnFixingOptions.icons.fix,
                    beginGroup: true,
                    items: fixedPositionItems
                }, {
                    text: columnFixingOptions.texts.unfix,
                    icon: columnFixingOptions.icons.unfix,
                    value: "none",
                    disabled: !column.fixed,
                    onItemClick: onItemClick
                })
            }
        }
        return items
    }
};
const rowsView = Base => class extends(baseStickyColumns(Base)) {
    _getMasterDetailWidth() {
        var _this$component$$elem, _this$component$$elem2;
        const componentWidth = (null === (_this$component$$elem = (_this$component$$elem2 = this.component.$element()).width) || void 0 === _this$component$$elem ? void 0 : _this$component$$elem.call(_this$component$$elem2)) ?? 0;
        return componentWidth - gridCoreUtils.getComponentBorderWidth(this, this._$element) - this.getScrollbarWidth()
    }
    _renderMasterDetailCell($row, row, options) {
        const $detailCell = super._renderMasterDetailCell($row, row, options);
        if (this.hasStickyColumns()) {
            $detailCell.addClass(this.addWidgetPrefix(CLASSES.stickyColumnLeft)).width(this._getMasterDetailWidth())
        }
        return $detailCell
    }
    _updateMasterDetailWidths() {
        const width = this._getMasterDetailWidth();
        const $masterDetailCells = this._getRowElements().children(".dx-master-detail-cell");
        setWidth($masterDetailCells, `${width}px`)
    }
    setStickyOffsets(rowIndex, offsets) {
        super.setStickyOffsets(rowIndex, offsets);
        this.setStickyOffsetsForGroupCells()
    }
    setStickyOffsetsForGroupCells() {
        const groupColumns = this._columnsController.getGroupColumns();
        let columns = this.getColumns();
        let widths = this.getColumnWidths();
        const columnsCountBeforeGroups = this._getColumnsCountBeforeGroups(columns);
        const rtlEnabled = this.option("rtlEnabled");
        if (rtlEnabled) {
            columns = rtlEnabled ? [...columns].reverse() : columns;
            widths = rtlEnabled ? [...widths].reverse() : widths
        }
        const $tableElement = this.getTableElement();
        groupColumns.forEach((column => {
            const columnIndex = columnsCountBeforeGroups + column.groupIndex + 1;
            const visibleColumnIndex = rtlEnabled ? columns.length - columnIndex - 1 : columnIndex;
            const offset = getStickyOffset(this._columnsController, columns, widths, visibleColumnIndex);
            const styleProps = normalizeOffset(offset);
            const $cells = $tableElement.children().children(".dx-group-row").find(`.dx-group-cell[aria-colindex='${columnIndex+1}']`);
            for (let i = 0; i < $cells.length; i += 1) {
                const cell = $cells.get(i);
                const container = $(cell).find(".dx-datagrid-group-row-container").get(0);
                Object.assign(cell.style, styleProps);
                Object.assign(container.style, styleProps)
            }
        }))
    }
    _resizeCore() {
        const hasStickyColumns = this.hasStickyColumns();
        super._resizeCore.apply(this, arguments);
        if (hasStickyColumns) {
            this._updateMasterDetailWidths()
        }
    }
    _renderCellContent($cell, options, renderOptions) {
        if (!isGroupRow(options) || !this.hasStickyColumns()) {
            return super._renderCellContent($cell, options, renderOptions)
        }
        const $container = $("<div>").addClass(this.addWidgetPrefix(CLASSES.groupRowContainer)).appendTo($cell);
        return super._renderCellContent($container, options, renderOptions)
    }
    _renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
        super._renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount);
        const stickySummarySelector = `.${this.addWidgetPrefix(CLASSES.stickyColumn)}`;
        if ($groupCell.parent().find(stickySummarySelector).length && GridCoreStickyColumnsDom.doesGroupCellEndInFirstColumn($groupCell)) {
            GridCoreStickyColumnsDom.addStickyColumnBorderRightClass($groupCell, this.addWidgetPrefix.bind(this))
        }
    }
    _handleScroll(e) {
        const hasStickyColumns = this.hasStickyColumns();
        super._handleScroll(e);
        if (hasStickyColumns) {
            const editorFactoryController = this.getController("editorFactory");
            const hasOverlayElements = editorFactoryController.hasOverlayElements();
            if (hasOverlayElements) {
                const $focusedElement = editorFactoryController.focus();
                editorFactoryController.focus($focusedElement)
            }
        }
    }
    _scrollToElement($element, offset) {
        let scrollOffset = offset;
        const hasStickyColumns = this.hasStickyColumns();
        if (hasStickyColumns) {
            var _this$getScrollable;
            const isFixedCell = GridCoreStickyColumnsDom.isFixedCell($element, this.addWidgetPrefix.bind(this));
            if (!$element.is("td") || isFixedCell) {
                return
            }
            const $row = null === $element || void 0 === $element ? void 0 : $element.closest("tr");
            const $cells = null === $row || void 0 === $row ? void 0 : $row.children();
            const $scrollContainer = null === (_this$getScrollable = this.getScrollable()) || void 0 === _this$getScrollable ? void 0 : _this$getScrollable.container();
            scrollOffset = GridCoreStickyColumnsDom.getScrollPadding($cells, $scrollContainer, this.addWidgetPrefix.bind(this))
        }
        super._scrollToElement($element, scrollOffset)
    }
};
const footerView = Base => class extends(baseStickyColumns(Base)) {};
const columnsResizer = Base => class extends Base {
    getSeparatorOffsetX($cell) {
        var _this$_columnHeadersV;
        const hasStickyColumns = null === (_this$_columnHeadersV = this._columnHeadersView) || void 0 === _this$_columnHeadersV ? void 0 : _this$_columnHeadersV.hasStickyColumns();
        if (hasStickyColumns) {
            const $container = $(this._columnHeadersView.getContent());
            const isFixedCellPinnedToRight = GridCoreStickyColumnsDom.isFixedCellPinnedToRight($cell, $container, this.addWidgetPrefix.bind(this));
            const isWidgetResizingMode = "widget" === this.option("columnResizingMode");
            if (isWidgetResizingMode && isFixedCellPinnedToRight) {
                var _$cell$offset;
                return (null === (_$cell$offset = $cell.offset()) || void 0 === _$cell$offset ? void 0 : _$cell$offset.left) ?? 0
            }
        }
        return super.getSeparatorOffsetX($cell)
    }
    _correctColumnIndexForPoint(point, correctionValue, columns) {
        const rtlEnabled = this.option("rtlEnabled");
        const isWidgetResizingMode = "widget" === this.option("columnResizingMode");
        const columnIndex = Math.max(point.index - 1, 0);
        const column = columns[columnIndex];
        const nextColumnIndex = this._getNextColumnIndex(columnIndex);
        const nextColumn = columns[nextColumnIndex];
        if (isWidgetResizingMode && !isFixedEdge(point, column, nextColumn)) {
            const $container = $(this._columnHeadersView.getContent());
            const isFixedCellPinnedToRight = GridCoreStickyColumnsDom.isFixedCellPinnedToRight($(point.item), $container, this.addWidgetPrefix.bind(this));
            if (isFixedCellPinnedToRight) {
                point.columnIndex -= rtlEnabled ? 1 : 0;
                return
            }
        }
        super._correctColumnIndexForPoint(point, correctionValue, columns)
    }
    _needToInvertResizing($cell) {
        const result = super._needToInvertResizing($cell);
        const isWidgetResizingMode = "widget" === this.option("columnResizingMode");
        if (!result && isWidgetResizingMode) {
            const $container = $(this._columnHeadersView.getContent());
            return GridCoreStickyColumnsDom.isFixedCellPinnedToRight($cell, $container, this.addWidgetPrefix.bind(this))
        }
        return result
    }
    _generatePointsByColumns() {
        var _this$_columnHeadersV2;
        const hasStickyColumns = null === (_this$_columnHeadersV2 = this._columnHeadersView) || void 0 === _this$_columnHeadersV2 ? void 0 : _this$_columnHeadersV2.hasStickyColumns();
        super._generatePointsByColumns(hasStickyColumns)
    }
    _pointCreated(point, cellsLength, columns) {
        var _this$_columnHeadersV3;
        const hasStickyColumns = null === (_this$_columnHeadersV3 = this._columnHeadersView) || void 0 === _this$_columnHeadersV3 ? void 0 : _this$_columnHeadersV3.hasStickyColumns();
        const result = super._pointCreated(point, cellsLength, columns);
        const needToCheckPoint = hasStickyColumns && cellsLength > 0;
        if (needToCheckPoint && !result) {
            const column = columns[point.index - 1];
            const nextColumnIndex = this._getNextColumnIndex(point.index - 1);
            const nextColumn = columns[nextColumnIndex];
            return GridCoreStickyColumnsDom.noNeedToCreateResizingPoint(this._columnHeadersView, {
                point: point,
                column: column,
                nextColumn: nextColumn
            }, this.addWidgetPrefix.bind(this))
        }
        return result
    }
};
const draggingHeader = Base => class extends Base {
    _generatePointsByColumns(options) {
        var _this$_columnHeadersV4;
        const hasStickyColumns = null === (_this$_columnHeadersV4 = this._columnHeadersView) || void 0 === _this$_columnHeadersV4 ? void 0 : _this$_columnHeadersV4.hasStickyColumns();
        const {
            sourceLocation: sourceLocation,
            sourceColumn: sourceColumn,
            targetDraggingPanel: targetDraggingPanel
        } = options;
        const isDraggingBetweenHeaders = "headers" === sourceLocation && "headers" === (null === targetDraggingPanel || void 0 === targetDraggingPanel ? void 0 : targetDraggingPanel.getName());
        if (hasStickyColumns && isDraggingBetweenHeaders) {
            const columnFixedPosition = getColumnFixedPosition(this._columnsController, sourceColumn);
            switch (true) {
                case sourceColumn.fixed && columnFixedPosition === StickyPosition.Left:
                    options.columnElements = GridCoreStickyColumnsDom.getLeftFixedCells(options.columnElements, this.addWidgetPrefix.bind(this));
                    options.startColumnIndex = options.columnElements.eq(0).index();
                    break;
                case sourceColumn.fixed && columnFixedPosition === StickyPosition.Right:
                    options.columnElements = GridCoreStickyColumnsDom.getRightFixedCells(options.columnElements, this.addWidgetPrefix.bind(this));
                    options.startColumnIndex = options.columnElements.eq(0).index();
                    break;
                default:
                    options.columnElements = GridCoreStickyColumnsDom.getNonFixedAndStickyCells(options.columnElements, this.addWidgetPrefix.bind(this));
                    options.startColumnIndex = options.columnElements.eq(0).index()
            }
        }
        return super._generatePointsByColumns(options, hasStickyColumns)
    }
    _pointCreated(point, columns, location, sourceColumn) {
        const hasStickyColumns = this._columnHeadersView.hasStickyColumns();
        const $cells = this._columnHeadersView.getColumnElements();
        const needToCheckPoint = hasStickyColumns && "headers" === location && (null === $cells || void 0 === $cells ? void 0 : $cells.length) && (!sourceColumn.fixed || sourceColumn.fixedPosition === StickyPosition.Sticky);
        const result = super._pointCreated(point, columns, location, sourceColumn);
        if (needToCheckPoint && !result) {
            return GridCoreStickyColumnsDom.noNeedToCreateReorderingPoint(point, $cells, $(this._columnHeadersView.getContent()), this.addWidgetPrefix.bind(this))
        }
        return result
    }
};
const editorFactory = Base => class extends Base {
    getOverlayContainerIfNeeded($cell) {
        const hasFixedColumns = this._rowsView.hasStickyColumns();
        const isFixedCell = GridCoreStickyColumnsDom.isFixedCell($cell, this.addWidgetPrefix.bind(this));
        if (hasFixedColumns && isFixedCell) {
            return $cell.closest(`.${this.addWidgetPrefix(CLASSES.stickyColumns)}`)
        }
        return
    }
    updateFocusOverlaySize($element, position) {
        const hasFixedColumns = this._rowsView.hasStickyColumns();
        if (!hasFixedColumns) {
            super.updateFocusOverlaySize($element, position)
        }
    }
    getFocusOverlaySize($element) {
        const hasFixedColumns = this._rowsView.hasStickyColumns();
        if (hasFixedColumns) {
            const elementRect = getBoundingRect($element.get(0));
            const isLastCell = GridCoreStickyColumnsDom.isLastCell($element);
            const isFixedCell = GridCoreStickyColumnsDom.isFixedCell($element, this.addWidgetPrefix.bind(this));
            return {
                width: elementRect.right - elementRect.left + (isLastCell || isFixedCell ? 0 : 1),
                height: elementRect.bottom - elementRect.top
            }
        }
        return super.getFocusOverlaySize($element)
    }
    getValidationMessageContainer($cell) {
        return this.getOverlayContainerIfNeeded($cell) ?? super.getValidationMessageContainer($cell)
    }
    getRevertButtonContainer($cell) {
        return this.getOverlayContainerIfNeeded($cell) ?? super.getRevertButtonContainer($cell)
    }
    getFocusOverlayContainer($focusedElement) {
        return this.getOverlayContainerIfNeeded($focusedElement) ?? super.getFocusOverlayContainer($focusedElement)
    }
    overlayPositionedHandler(e, isOverlayVisible) {
        const columnHeaders = this.getView("columnHeadersView");
        const hasStickyColumns = columnHeaders.hasStickyColumns();
        super.overlayPositionedHandler(e, isOverlayVisible);
        if (hasStickyColumns) {
            const $cell = $(e.element).closest("td");
            if (!GridCoreStickyColumnsDom.isFixedCell($cell, this.addWidgetPrefix.bind(this))) {
                const $wrapper = e.component.$wrapper();
                const $overlayContent = e.component.$content();
                const isOutsideVisibleArea = GridCoreStickyColumnsDom.isOutsideVisibleArea($overlayContent, $(columnHeaders.getColumnElements()), $(columnHeaders.getContent()), this.addWidgetPrefix.bind(this));
                $wrapper.css("zIndex", isOutsideVisibleArea ? 1 : (null === this || void 0 === this ? void 0 : this.getOverlayBaseZIndex()) ?? 0)
            }
        }
    }
    updateFocusOverlay($element) {
        let isHideBorder = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
        if (!isHideBorder) {
            const isFixedCell = GridCoreStickyColumnsDom.isFixedCell($element, this.addWidgetPrefix.bind(this));
            this._$focusOverlay.toggleClass(CLASSES.focusedFixedElement, isFixedCell);
            const isGroupElement = isGroupRowElement($element);
            const isGroupFooterRowElement = isGroupFooterRow($element);
            const isAdaptiveElement = isAdaptiveItem($element);
            if (isFixedCell || isGroupElement || isGroupFooterRowElement || isAdaptiveElement) {
                this._$focusOverlay.toggleClass(CLASSES.focusedFixedElement, true)
            }
        }
        super.updateFocusOverlay($element, isHideBorder)
    }
};
const resizing = Base => class extends Base {
    resize() {
        const result = super.resize();
        const hasStickyColumns = this._columnHeadersView.hasStickyColumns();
        if (hasStickyColumns && null !== this && void 0 !== this && this.hasResizeTimeout()) {
            this._rowsView.setStickyOffsets()
        }
        return result
    }
};
const keyboardNavigation = Base => class extends Base {
    headerTabKeyHandler(_ref) {
        var _this$_columnHeadersV5, _this$_rowsView;
        let {
            originalEvent: originalEvent,
            shift: shift
        } = _ref;
        const hasStickyColumns = null === (_this$_columnHeadersV5 = this._columnHeadersView) || void 0 === _this$_columnHeadersV5 ? void 0 : _this$_columnHeadersV5.hasStickyColumns();
        const scrollable = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView.getScrollable();
        if (hasStickyColumns && scrollable) {
            const $cell = $(originalEvent.target).closest("td");
            const $nextCell = GridCoreStickyColumnsDom.getNextHeaderCell($cell, shift ? "previous" : "next");
            const isFixedCell = GridCoreStickyColumnsDom.isFixedCell($nextCell, this.addWidgetPrefix.bind(this));
            if ($nextCell.length && !isFixedCell) {
                const $cells = $(this._columnHeadersView.getColumnElements());
                const cellIsOutsideVisibleArea = GridCoreStickyColumnsDom.isOutsideVisibleArea($nextCell, $cells, $(this._columnHeadersView.getContent()), this.addWidgetPrefix.bind(this));
                if (cellIsOutsideVisibleArea) {
                    const scrollPadding = GridCoreStickyColumnsDom.getScrollPadding($cells, scrollable.container(), this.addWidgetPrefix.bind(this));
                    const scrollPosition = getElementLocationInternal($nextCell[0], "horizontal", $(this._columnHeadersView.getContent())[0], scrollable.scrollOffset(), scrollPadding, this.addWidgetPrefix("table"));
                    scrollable.scrollTo({
                        x: scrollPosition
                    })
                }
            }
        }
    }
};
export const stickyColumnsModule = {
    extenders: {
        views: {
            columnHeadersView: columnHeadersView,
            rowsView: rowsView,
            footerView: footerView
        },
        controllers: {
            columnsResizer: columnsResizer,
            draggingHeader: draggingHeader,
            editorFactory: editorFactory,
            resizing: resizing,
            keyboardNavigation: keyboardNavigation
        }
    }
};
